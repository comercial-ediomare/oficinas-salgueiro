<!doctype html> 
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Inscrição nas Oficinas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 2rem auto; max-width: 860px; color: #222; padding: 0 1rem; }
    h1 { text-align: center; margin-bottom: 1rem; color: #004b6b; }
    form { margin-top: 1rem; }
    fieldset.slot { margin: 1.25em 0; padding: 1em; border: 2px solid #ccc; border-radius: 10px; }
    legend { font-weight: bold; color: #333; }
    label { display: block; margin-bottom: .45em; }
    label.bloqueada { color: #888; }
    label.bloqueada small { color: #aaa; }
    .flash { padding: 1em; border-radius: 6px; margin-bottom: 1em; }
    .flash.error { background: #ffe0e0; color: #a00; border: 1px solid #f99; }
    .flash.message { background: #e0f8e0; color: #060; border: 1px solid #9c9; }
    input[type="text"], input[type="email"] { width: 100%; padding: .6em; border: 1px solid #bbb; border-radius: 6px; margin-top: .25em; }
    button { background: #0074a6; color: #fff; border: none; padding: .75em 1.5em; border-radius: 6px; font-size: 1rem; cursor: pointer; margin-top: 1rem; }
    button:hover { background: #005c83; }
    small.muted { color: #666; }
  </style>
</head>
<body>
  <h1>Inscrição nas Oficinas</h1>

  {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
      {% for cat, msg in messages %}
        <div class="flash {{ cat }}">{{ msg }}</div>
      {% endfor %}
    {% endif %}
  {% endwith %}

  <form method="post" action="{{ url_for('inscrever') }}">
    <label>Nome completo:
      <input type="text" name="full_name" required>
    </label>

    <label style="margin-top:.6em;">E-mail:
      <input type="email" name="email" required>
    </label>

    <p><strong>Escolha de 1 a 4 oficinas (máximo 1 por horário e sem repetir):</strong></p>

    {% for slot in slots %}
      <fieldset class="slot">
        <legend>{{ loop.index }}º Horário — {{ slot.hora }}</legend>
        <div class="oficinas">
          {% set slotAvail = avail.get(slot.id, {}) %}
          {% for w in workshops %}
            {% set info = slotAvail.get(w['id']) %}
            {% set is_blocked = (info is none) %}
            {% set remaining = (info.remaining if info else 0) %}
            {% set cap = (info.capacity if info else 0) %}
            {% set is_full = (not is_blocked and remaining <= 0) %}

            {% if not is_blocked %}
              <label>
                <input type="radio"
                       class="opt oficina-radio"
                       name="slot_{{ slot.id }}"
                       value="{{ w['id'] }}"
                       data-workshop-id="{{ w['id'] }}"
                       data-slot-id="{{ slot.id }}"
                       {% if is_full %}disabled data-locked="full"{% endif %}
                       onchange="handleChange(event)">
                {{ w["name"] }}
                {% if is_full %}
                  <small class="muted">(lotada neste horário)</small>
                {% else %}
                  <small class="muted">(vagas: {{ remaining }}/{{ cap }})</small>
                {% endif %}
              </label>
            {% else %}
              <label class="bloqueada">
                <input type="radio" disabled data-locked="blocked">
                {{ w["name"] }} <small class="muted">(não disponível neste horário)</small>
              </label>
            {% endif %}
          {% endfor %}

          <!-- opção de não escolher nada neste horário (no FINAL) -->
          <label>
            <input type="radio"
                   class="opt slot-none"
                   name="slot_{{ slot.id }}"
                   value=""
                   data-slot-id="{{ slot.id }}"
                   onchange="handleChange(event)">
            NÃO ESCOLHER NESTE HORÁRIO
          </label>
        </div>
      </fieldset>
    {% endfor %}

    <p>
      <label>
        <input type="checkbox" name="consent" required>
        Autorizo o uso dos meus dados para organização das oficinas.
      </label>
    </p>

    <button type="submit" id="submitBtn" disabled>Enviar inscrição</button>
  </form>

  <script>
    // Utilitários
    const submitBtn = document.getElementById('submitBtn');

    function qsa(sel, ctx=document){ return Array.from(ctx.querySelectorAll(sel)); }

    // Mapa: slotId -> radio "não escolher"
    function mapNoneBySlot() {
      const map = {};
      qsa('.slot-none').forEach(n => { map[n.dataset.slotId] = n; });
      return map;
    }

    // Agrupar radios por oficina (id)
    function groupByWorkshop() {
      const byWorkshop = new Map();
      qsa('input[type="radio"].oficina-radio').forEach(r => {
        const wid = r.dataset.workshopId;
        if (!byWorkshop.has(wid)) byWorkshop.set(wid, []);
        byWorkshop.get(wid).push(r);
      });
      return byWorkshop;
    }

    // Lê seleções atuais: { slotId: value } ("" ou workshopId)
    function getSelections() {
      const out = {};
      const names = [...new Set(qsa('input[type="radio"][name^="slot_"]').map(r => r.name))];
      names.forEach(name => {
        const checked = document.querySelector(`input[name="${name}"]:checked`);
        const slotId = name.replace('slot_', '');
        out[slotId] = checked ? checked.value : "";
      });
      return out;
    }

    // Botão submit habilitado se nº de escolhas ∈ [1,4]
    function updateSubmitEnabled() {
      const chosenCount = qsa('input[type="radio"][name^="slot_"]:checked')
                           .filter(r => r.value).length;
      submitBtn.disabled = !(chosenCount >= 1 && chosenCount <= 4);
    }

    // Reaplica as regras de (não) duplicidade entre horários
    function applyCrossDisable() {
      const selections = getSelections();
      const chosenWids = new Set(Object.values(selections).filter(v => v && /^\d+$/.test(v)));
      const byWorkshop = groupByWorkshop();

      // 1) Reabilita dinamicamente tudo que NÃO veio travado pelo servidor (data-locked)
      byWorkshop.forEach(list => {
        list.forEach(r => {
          if (!r.dataset.locked) {
            r.disabled = false;
          }
        });
      });

      // 2) Se uma oficina foi escolhida em um slot, desabilita essa mesma oficina nos outros slots
      byWorkshop.forEach(list => {
        // Descobre se está escolhida em algum slot
        const checked = list.find(r => r.checked && r.value);
        if (checked) {
          list.forEach(r => {
            if (r !== checked && !r.dataset.locked) {
              r.disabled = true;
            }
          });
        } else {
          // Se não há nenhum slot com essa oficina marcada, nada a fazer aqui;
          // a desabilitação dinâmica será resolvida pelo conjunto chosenWids abaixo.
        }
      });

      // 3) Blindagem adicional: qualquer radio de oficina cujo WID esteja escolhido em OUTRO slot fica desabilitado
      qsa('.oficina-radio').forEach(r => {
        if (r.dataset.locked) return; // respeita bloqueio do servidor (bloqueada/lotada)
        const wid = r.dataset.workshopId;
        const slot = r.dataset.slotId;
        const current = selections[slot]; // "" ou wid
        const chosenElsewhere = chosenWids.has(wid) && current !== wid;
        if (chosenElsewhere) {
          r.disabled = true;
        }
      });

      updateSubmitEnabled();
    }

    // Ao escolher uma oficina, desmarca a mesma oficina em outros slots e marca "não escolher" nesses slots
    function enforceUniqueOnSelect(changedRadio) {
      if (!changedRadio.classList.contains('oficina-radio')) return;
      if (!changedRadio.checked) return;

      const wid = changedRadio.dataset.workshopId;
      const slot = changedRadio.dataset.slotId;
      const noneBySlot = mapNoneBySlot();

      qsa(`.oficina-radio[data-workshop-id="${wid}"]`).forEach(r => {
        if (r === changedRadio) return;
        if (r.checked) {
          r.checked = false;
          const otherSlot = r.dataset.slotId;
          const none = noneBySlot[otherSlot];
          if (none) none.checked = true;
        }
      });
    }

    // Handler central de mudança
    function handleChange(e) {
      enforceUniqueOnSelect(e.target);
      applyCrossDisable();
    }

    // Estado inicial: nada selecionado; aplica apenas regras cruzadas (respeitando data-locked do servidor)
    document.addEventListener('DOMContentLoaded', () => {
      applyCrossDisable();
    });
  </script>
</body>
</html>
